<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>У пошуках Підводної Синагоги</title>
<style>
* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

html, body {
  background: #000 !important;
  color: #FFF !important;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  padding: 20px;
  margin: 0;
  overflow-y: auto;
  -webkit-text-size-adjust: 100%;
  background-color: #000 !important;
}

.card {
  width: 100%;
  max-width: 980px;
  padding: 0;
  background: transparent !important;
  border-radius: 0;
  box-shadow: none;
  flex-shrink: 0;
}

.header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 15px;
  gap: 15px;
}

h1 {
  font-size: 22px;
  color: #FFF !important;
  letter-spacing: 0.01em;
  text-align: left;
  word-break: break-word;
  line-height: 1.4;
  white-space: pre-line;
  flex: 1;
}

.content {
  background: transparent !important;
  padding: 0;
  border-radius: 0;
  line-height: 1.6;
  font-size: 18px;
  color: #FFF !important;
}

.content p {
  margin-bottom: 15px;
  color: #FFF !important;
}

.content p:last-child {
  margin-bottom: 0;
}

.year {
  font-weight: bold;
  color: #AAA !important;
  margin-top: 10px;
}

button {
  background: #555;
  border: none;
  color: #FFF;
  padding: 0;
  border-radius: 5px;
  cursor: pointer;
  white-space: nowrap;
  -webkit-tap-highlight-color: rgba(0,0,0,0);
  flex-shrink: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 44px;
  height: 44px;
  position: relative;
}

button:active {
  background: #777;
}

button svg {
  width: 28px;
  height: 28px;
}

@media (max-width: 600px) {
  body {
    padding: 10px;
  }
  .header {
    flex-direction: column;
    align-items: flex-start;
  }
  h1 {
    font-size: 18px;
  }
  .content {
    font-size: 16px;
  }
  button {
    align-self: flex-end;
  }
}
</style>
</head>
<body>
<div class="card" role="main">
  <div class="header">
    <h1>У пошуках Підводної Синагоги, 2025,
полотно / акрил, олія, 140 × 140 см.</h1>
    <button id="muteBtn" aria-label="Звук">
      <svg viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
        <!-- Зовнішній контур вуха -->
        <path d="M 20 6 C 22 6 25 8 26 12 C 27 16 26 20 24 23 C 23 24 22 25 20 25" 
              stroke="#FFFFFF" stroke-width="2.5" stroke-linecap="round" fill="none"/>
        <!-- Внутрішня частина вуха -->
        <path d="M 20 10 C 21 10 22 11 22.5 13 C 23 15 22.5 17 21 18.5" 
              stroke="#FFFFFF" stroke-width="2.5" stroke-linecap="round" fill="none"/>
        <!-- Мочка вуха -->
        <path d="M 19 24 C 18 25 17 25.5 16 25" 
              stroke="#FFFFFF" stroke-width="2.5" stroke-linecap="round" fill="none"/>
      </svg>
    </button>
  </div>

  <div class="content">
    <p class="year">1941–1942</p>
    <p>Під час Другої світової війни, після окупації польського Белза нацистами, місто стало сценою масових убивств і депортацій. Фашисти знищили хасидську синагогу й майже всю єврейську громаду.</p>

    <p class="year">1945–1948</p>
    <p>Після закінчення війни, в умовах радянської окупації, відновлення колишнього життя в Белзі виявилося неможливим. Уцілілі хасиди, прагнучи відродити громаду, почали шукати нове місце для відновлення релігійних традицій і втраченої синагоги.<br>
    З проголошенням у 1948 році держави Ізраїль вибір остаточно зупинився на Єрусалимі.</p>

    <p>У 1950‑х роках хасиди з Белза, розсіяні тоді по країнах Америки та Європи, почали стікатися до Святих місць і будувати нове життя.</p>

    <p>На початку 1990‑х одеський художник Леонід Войцехов розробив проєкт підводної синагоги — один із найамбітніших і найконцептуальніших у його творчості. Проєкт передбачав створення синагоги під водою як символу зв'язку між духовністю й природою, а також відображення глибоких культурних та історичних шарів єврейської традиції. Хоча проєкт підводної синагоги так і не було реалізовано, він залишився важливою частиною творчої спадщини Войцехова та яскраво засвідчив його нестандартний, експериментальний підхід до мистецтва.</p>

    <p>У 2000 році в Єрусалимі було завершено будівництво нової Белзської синагоги — однієї з найбільших і найзначущіших у світі. Будівля спроєктована в традиційному хасидському стилі з включенням архітектурних мотивів синагоги, втраченої в Белзі в роки Другої світової війни.</p>

    <p class="year">Кінець 2024 року</p>
    <p>Роздуми про трагічну долю белзьких хасидів, спогади про бесіди з Леонідом Войцеховим, осмислення стрімко мінливого світу та його калейдоскопічного відображення в сучасному мистецтві породили в автора ідею створення незвичайного твору, що поєднує воєдино фрагменти історій і вигадок, можливого й неможливого, в єдиному просторі духовних образів. Образів тих цінностей, які ми творимо навколо себе, і тих, що вибудовуємо всередині себе.</p>

    <p>За уважного погляду на картину можна помітити долоню Фатіми та зірку Давида. Хаотична зміна форм, характерна для нашої мінливої реальності, передана через мотиви, що відсилають до ікон сучасного мистецтва. Серед заростей ламінарії та силуетів глибоководних риб можна побачити декупажі Матісса, квадрат Малевича, проуни Лисицького, бляшанку Воргола, гарбуз Кусами, чоловічків Харінга та пікселі Мондріана.</p>

    <p>Ця картина не є частиною проєкту «Глобальна адаптація», однак увійшла до експозиції як яскравий приклад героїчного сьогодення — часу, коли практично з нуля можна повернути народові його духовні цінності й відтворити те, що було втрачено. Вона нагадує про те, що немає нічого неможливого: якщо ми здатні протистояти тим руйнівним силам, які приносять нам процеси глобалізації, у нас залишається реальний шанс на успіх і збереження власної ідентичності.</p>
  </div>
</div>

<script>
let audioCtx = null;
let masterGain = null;
let whaleSound = { running: false, mute: false, timeout: null, highTimeout: null, trillTimeout: null };
let continuousHighOscs = null;

function initAudio() {
  if (audioCtx) return;
  try {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    masterGain = audioCtx.createGain();
    masterGain.gain.value = whaleSound.mute ? 0 : 0.5;
    masterGain.connect(audioCtx.destination);

    // Створюємо AudioListener для позиціонування звуків
    audioCtx.listener.positionX.value = 0;
    audioCtx.listener.positionY.value = 0;
    audioCtx.listener.positionZ.value = 0;

    whaleSound.running = true;
    scheduleWhaleSound();
    startContinuousHighWhale();
    scheduleTrillSound();
  } catch (e) {
    console.warn('AudioContext not available:', e);
    whaleSound.running = false;
    document.getElementById('muteBtn').style.display = 'none';
  }
}

// Низький голос кита (вже існуючий)
function makeWhaleCall(type) {
  if (!audioCtx || !whaleSound.running) return;

  const now = audioCtx.currentTime;
  const duration = type === 'long' ? 7.5 : 5.2;
  
  const osc1 = audioCtx.createOscillator();
  const osc2 = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  const filter = audioCtx.createBiquadFilter();
  const panner = audioCtx.createPanner(); // Створюємо PannerNode

  // Рандомна початкова позиція для низьких звуків
  const startX = Math.random() * 2 - 1; // Від -1 (ліворуч) до 1 (праворуч)
  panner.positionX.value = startX;
  panner.positionY.value = 0;
  panner.positionZ.value = -0.5; // Трохи позаду слухача

  filter.type = 'lowpass';
  filter.frequency.value = 500;
  filter.Q.value = 1.5;
  
  osc1.type = 'sine';
  osc2.type = 'sine';
  
  if (type === 'long') {
    osc1.frequency.setValueAtTime(130, now);
    osc1.frequency.linearRampToValueAtTime(170, now + 2.0);
    osc1.frequency.linearRampToValueAtTime(150, now + 4.5);
    osc1.frequency.linearRampToValueAtTime(120, now + 6.5);
    osc1.frequency.linearRampToValueAtTime(100, now + duration);
    
    osc2.frequency.setValueAtTime(135, now);
    osc2.frequency.linearRampToValueAtTime(175, now + 2.0);
    osc2.frequency.linearRampToValueAtTime(155, now + 4.5);
    osc2.frequency.linearRampToValueAtTime(125, now + 6.5);
    osc2.frequency.linearRampToValueAtTime(105, now + duration);
  } else {
    osc1.frequency.setValueAtTime(160, now);
    osc1.frequency.linearRampToValueAtTime(190, now + 1.5);
    osc1.frequency.linearRampToValueAtTime(140, now + 3.5);
    osc1.frequency.linearRampToValueAtTime(115, now + duration);
    
    osc2.frequency.setValueAtTime(165, now);
    osc2.frequency.linearRampToValueAtTime(195, now + 1.5);
    osc2.frequency.linearRampToValueAtTime(145, now + 3.5);
    osc2.frequency.linearRampToValueAtTime(120, now + duration);
  }
  
  gain.gain.setValueAtTime(0.0001, now);
  gain.gain.exponentialRampToValueAtTime(0.12, now + 1.8);
  gain.gain.linearRampToValueAtTime(0.15, now + duration * 0.4);
  gain.gain.linearRampToValueAtTime(0.10, now + duration * 0.7);
  gain.gain.exponentialRampToValueAtTime(0.0001, now + duration);
  
  osc1.connect(filter);
  osc2.connect(filter);
  filter.connect(gain);
  gain.connect(panner); // Підключаємо до PannerNode
  panner.connect(masterGain); // PannerNode до masterGain
  
  osc1.start(now);
  osc2.start(now);
  osc1.stop(now + duration + 0.1);
  osc2.stop(now + duration + 0.1);

  // Рух звуку
  const endX = -startX; // Переміщуємо в протилежну сторону
  panner.positionX.linearRampToValueAtTime(endX, now + duration);
}

// Високий голос кита (безперервний з пульсацією) - тихіше на 25%
function startContinuousHighWhale() {
  if (!audioCtx || !whaleSound.running) return;

  const osc1 = audioCtx.createOscillator();
  const osc2 = audioCtx.createOscillator();
  const osc3 = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  const filter = audioCtx.createBiquadFilter();
  const reverb = audioCtx.createDelay();
  const reverbGain = audioCtx.createGain();
  const panner = audioCtx.createPanner(); // Створюємо PannerNode для високих звуків

  panner.positionX.value = 0; // Починаємо з центру
  panner.positionY.value = 0;
  panner.positionZ.value = -0.2; // Трохи ближче

  reverb.delayTime.value = 0.3;
  reverbGain.gain.value = 0.4;
  
  filter.type = 'bandpass';
  filter.frequency.value = 1200;
  filter.Q.value = 3.0;
  
  osc1.type = 'sine';
  osc2.type = 'sine';
  osc3.type = 'sine';
  
  const baseFreq = 900;
  osc1.frequency.value = baseFreq;
  osc2.frequency.value = baseFreq + 50;
  osc3.frequency.value = baseFreq - 30;
  
  // Безперервна пульсація гучності (зменшено на 25%)
  const now = audioCtx.currentTime;
  gain.gain.setValueAtTime(0.0375, now); // Було 0.05, тепер 0.0375
  
  function pulsate(startTime) {
    if (!whaleSound.running) return;
    
    const t = startTime;
    const cycleDuration = 8 + Math.random() * 4;
    
    gain.gain.cancelScheduledValues(t);
    gain.gain.setValueAtTime(gain.gain.value, t);
    gain.gain.linearRampToValueAtTime(0.075, t + cycleDuration * 0.3); // Було 0.10, тепер 0.075
    gain.gain.linearRampToValueAtTime(0.0375, t + cycleDuration); // Було 0.05, тепер 0.0375
    
    // Модуляція частоти
    const freqShift = 200 + Math.random() * 300;
    osc1.frequency.cancelScheduledValues(t);
    osc1.frequency.setValueAtTime(osc1.frequency.value, t);
    osc1.frequency.linearRampToValueAtTime(baseFreq + freqShift, t + cycleDuration * 0.5);
    osc1.frequency.linearRampToValueAtTime(baseFreq, t + cycleDuration);
    
    osc2.frequency.cancelScheduledValues(t);
    osc2.frequency.setValueAtTime(osc2.frequency.value, t);
    osc2.frequency.linearRampToValueAtTime(baseFreq + 50 + freqShift, t + cycleDuration * 0.5);
    osc2.frequency.linearRampToValueAtTime(baseFreq + 50, t + cycleDuration);
    
    setTimeout(() => pulsate(audioCtx.currentTime), cycleDuration * 1000);

    // Рух звуку для високих китів
    const targetX = Math.random() * 2 - 1; // Випадкова позиція
    panner.positionX.linearRampToValueAtTime(targetX, t + cycleDuration);
  }
  
  osc1.connect(filter);
  osc2.connect(filter);
  osc3.connect(filter);
  filter.connect(gain);
  gain.connect(panner); // Підключаємо до PannerNode
  panner.connect(masterGain); // PannerNode до masterGain
  gain.connect(reverb);
  reverb.connect(reverbGain);
  reverbGain.connect(masterGain);
  
  osc1.start(now);
  osc2.start(now);
  osc3.start(now);
  
  continuousHighOscs = { osc1, osc2, osc3, gain };
  
  pulsate(now);
}

// Дуже високий голос - хаотична, переривчаста трель кита (тихіше на 20%)
function makeTrillSound() {
  if (!audioCtx || !whaleSound.running) return;

  const now = audioCtx.currentTime;
  const baseDuration = 1.5 + Math.random() * 1.5; // Коротка, хаотична тривалість
  const numNotes = 5 + Math.floor(Math.random() * 5); // Менше нот
  const overallGain = 0.028; // Зменшено на 20% від 0.035
  
  for (let i = 0; i < numNotes; i++) {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    const filter = audioCtx.createBiquadFilter();
    const panner = audioCtx.createPanner(); // Створюємо PannerNode для трелей

    const startX = Math.random() * 2 - 1; // Рандомна початкова позиція
    panner.positionX.value = startX;
    panner.positionY.value = 0;
    panner.positionZ.value = -0.1; // Ближче до слухача
    
    filter.type = 'bandpass';
    filter.frequency.value = 2000 + Math.random() * 1000;
    filter.Q.value = 3.0; // Трохи менша добротність для меншої виразності
    
    osc.type = 'sine';
    
    const noteStart = now + (i / numNotes) * baseDuration + Math.random() * 0.2; // Хаотичний старт
    const noteDuration = 0.1 + Math.random() * 0.2; // Коротка тривалість ноти
    const freq = 1800 + Math.random() * 1200;
    
    osc.frequency.setValueAtTime(freq, noteStart);
    osc.frequency.linearRampToValueAtTime(freq + (Math.random() * 300 - 150), noteStart + noteDuration); // Менший діапазон модуляції
    
    gain.gain.setValueAtTime(0.0001, noteStart);
    gain.gain.exponentialRampToValueAtTime(overallGain, noteStart + noteDuration * 0.3);
    gain.gain.exponentialRampToValueAtTime(0.0001, noteStart + noteDuration);
    
    osc.connect(filter);
    filter.connect(gain);
    gain.connect(panner); // Підключаємо до PannerNode
    panner.connect(masterGain); // PannerNode до masterGain
    
    osc.start(noteStart);
    osc.stop(noteStart + noteDuration);

    // Рух звуку для трелей
    const endX = -startX; // Переміщуємо в протилежну сторону
    panner.positionX.linearRampToValueAtTime(endX, noteStart + noteDuration);
  }
}

function scheduleWhaleSound() {
  if (!whaleSound.running) return;
  
  const callType = Math.random() > 0.35 ? 'long' : 'short';
  makeWhaleCall(callType);
  
  const nextDelay = 8000 + Math.random() * 10000;
  
  whaleSound.timeout = setTimeout(scheduleWhaleSound, nextDelay);
}

function scheduleTrillSound() {
  if (!whaleSound.running) return;
  
  makeTrillSound();
  
  // Хаотичні перерви
  const nextDelay = 5000 + Math.random() * 15000; // Збережено хаотичні перерви
  
  whaleSound.trillTimeout = setTimeout(scheduleTrillSound, nextDelay);
}

const muteBtn = document.getElementById('muteBtn');

muteBtn.onclick = () => {
  if (!audioCtx) {
    initAudio();
    if (!audioCtx) return;
  }
  if (audioCtx && audioCtx.state === 'suspended') {
    audioCtx.resume().catch(() => {});
  }

  whaleSound.mute = !whaleSound.mute;
  
  const now = audioCtx.currentTime;
  masterGain.gain.cancelScheduledValues(now);
  masterGain.gain.setValueAtTime(masterGain.gain.value, now);
  masterGain.gain.exponentialRampToValueAtTime(whaleSound.mute ? 0.0001 : 0.5, now + 0.3);
  
  muteBtn.style.background = whaleSound.mute ? '#333' : '#555';
};

function userInit() {
  if (!audioCtx) {
    initAudio();
  }
  if (audioCtx && audioCtx.state === 'suspended') {
    audioCtx.resume().catch(() => {});
  }
}

window.addEventListener('click', userInit, { once: true });
window.addEventListener('touchstart', userInit, { once: true });
</script>
</body>
</html>
